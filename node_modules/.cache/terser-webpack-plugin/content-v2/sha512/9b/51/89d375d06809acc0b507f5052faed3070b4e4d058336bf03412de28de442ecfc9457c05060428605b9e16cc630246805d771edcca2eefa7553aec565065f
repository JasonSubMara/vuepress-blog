{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{313:function(n,r,e){\"use strict\";e.r(r);var t=e(22),a=Object(t.a)({},(function(){var n=this.$createElement,r=this._self._c||n;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":this.$parent.slotKey}},[r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[this._v(\"数组常用方法\\n\\n先献上数组方法懒人图一张祭天！（除了Array.keys()/Array.values()/Array.entries()基本都有）：\\n\\n数组方法大全\\n生成类似[1-100]这样的的数组：\\n测试大量数组数据时可以：\\nlet arr = new Array(100).fill(0).map((item, index) => index + 1)\\n数组解构赋值应用\\n// 交换变量\\n[a, b] = [b, a]\\n[o.a, o.b] = [o.b, o.a]\\n// 生成剩余数组\\nconst [a, ...rest] = [...'asdf'] // a：'a'，rest: [\\\"s\\\", \\\"d\\\", \\\"f\\\"]\\n数组浅拷贝\\nconst arr = [1, 2, 3]\\nconst arrClone = [...arr]\\n// 对象也可以这样浅拷贝\\nconst obj = { a: 1 }\\nconst objClone = { ...obj }\\n浅拷贝方法有很多如arr.slice(0, arr.length)/Arror.from(arr)等，但是用了...操作符之后就不会再想用其他的了~\\n数组合并\\nconst arr1 = [1, 2, 3]\\nconst arr2 = [4, 5, 6]\\nconst arr3 = [7, 8, 9]\\nconst arr = [...arr1, ...arr2, ...arr3]\\narr1.concat(arr2, arr3)同样可以实现合并，但是用了...操作符之后就不会再想用其他的了~\\n数组去重\\nconst arr = [1, 1, 2, 2, 3, 4, 5, 5]\\nconst newArr = [...new Set(arr)]\\nnew Set(arr)接受一个数组参数并生成一个set结构的数据类型。set数据类型的元素不会重复且是Array Iterator，所以可以利用这个特性来去重。\\n数组取交集\\nconst a = [0, 1, 2, 3, 4, 5]\\nconst b = [3, 4, 5, 6, 7, 8]\\nconst duplicatedValues = [...new Set(a)].filter(item => b.includes(item))\\nduplicatedValues // [3, 4, 5]\\n数组取差集\\nconst a = [0, 1, 2, 3, 4, 5]\\nconst b = [3, 4, 5, 6, 7, 8]\\nconst diffValues = [...new Set([...a, ...b])].filter(item => !b.includes(item) || !a.includes(item)) // [0, 1, 2, 6, 7, 8]\\n数组转对象\\nconst arr = [1, 2, 3, 4]\\nconst newObj = {...arr} // {0: 1, 1: 2, 2: 3, 3: 4}\\nconst obj = {0: 0, 1: 1, 2: 2, length 3}\\n// 对象转数组不能用展开操作符，因为展开操作符必须用在可迭代对象上\\nlet newArr = [...obj] // Uncaught TypeError: object is not iterable...\\n// 可以使用Array.form()将类数组对象转为数组\\nlet newArr = Array.from(obj) // [0, 1, 2]\\n数组常用遍历\\n\\n数组常用遍历有 forEach、every、some、filter、map、reduce、reduceRight、find、findIndex 等方法，很多方法都可以达到同样的效果。数组方法不仅要会用，而且要用好。要用好就要知道什么时候用什么方法。\\n遍历的混合使用\\nfilter、map方法返回值仍旧是一个数组，所以可以搭配其他数组遍历方法混合使用。注意遍历越多效率越低~\\nconst arr = [1, 2, 3, 4, 5]\\nconst value = arr\\n    .map(item => item * 3)\\n    .filter(item => item % 2 === 0)\\n    .map(item => item + 1)\\n    .reduce((prev, curr) => prev + curr, 0)\\n检测数组所有元素是否都符合判断条件\\nconst arr = [1, 2, 3, 4, 5]\\nconst isAllNum = arr.every(item => typeof item === 'number')\\n检测数组是否有元素符合判断条件\\nconst arr = [1, 2, 3, 4, 5]\\nconst hasNum = arr.some(item => typeof item === 'number')\\n找到第一个符合条件的元素/下标\\nconst arr = [1, 2, 3, 4, 5]\\nconst findItem = arr.find(item => item === 3) // 返回子项\\nconst findIndex = arr.findIndex(item => item === 3) // 返回子项的下标\\n数组使用误区\\n\\n数组的方法很多，很多方法都可以达到同样的效果，所以在使用时要根据需求使用合适的方法。\\n垃圾代码产生的很大原因是数组常用方法使用不当，这里有一下需要注意的点：\\narray.includes() 和 array.indexOf()\\narray.includes() 返回布尔值，array.indexOf() 返回数组子项的索引。indexOf 一定要在需要索引值的情况下使用。\\nconst arr = [1, 2, 3, 4, 5]\\n\\n// 使用indexOf，需要用到索引值\\nconst index = arr.indexOf(1) // 0\\nif (~index) { // 若index === -1，~index得到0，判断不成立；若index不为-1，则~index得到非0，判断成立。\\n    arr.spilce(index, 1)\\n}\\n\\n// 使用includes，不需要用到索引值\\n// 此时若用indexOf会造成上下文上的阅读负担：到底其他地方有没有用到这个index?\\nconst isExist = arr.includes(6) // true\\nif (!isExist) {\\n    arr.push(6)\\n}\\narray.find() 、 array.findIndex() 和 array.some()\\narray.find()返回值是第一个符合条件的数组子项，array.findIndex() 返回第一个符合条件的数组子项的下标，array.some() 返回有无复合条件的子项，如有返回true，若无返回false。注意这三个都是短路操作，即找到符合条件的之后就不在继续遍历。\\n在需要数组的子项的时候使用array.find() ；需要子项的索引值的时候使用 array.findIndex() ；而若只需要知道有无符合条件的子项，则用 array.some()。\\nconst arr = [{label: '男', value: 0}, {label: '女', value: 1}, {label: '不男不女', value: 2}]\\n\\n// 使用some\\nconst isExist = arr.some(item => item.value === 2)\\nif (isExist) {\\n    console.log('哈哈哈找到了')\\n}\\n\\n// 使用find\\nconst item = arr.find(item => item.value === 2)\\nif (item) {\\n    console.log(item.label)\\n}\\n\\n// 使用findIndex\\nconst index = arr.findIndex(item => item.value === 2)\\nif (~index) {\\n    const delItem = arr[index]\\n    arr.splice(index, 1)\\n    console.log(`你删除了${delItem.label}`)\\n}\\n建议在只需要布尔值的时候和数组子项是字符串或数字的时候使用 array.some()：\\n// 当子包含数字0的时候可能出错\\nconst arr = [0, 1, 2, 3, 4]\\n\\n// 正确\\nconst isExist = arr.some(item => item === 0)\\nif (isExist) {\\n    console.log('存在要找的子项，很舒服~')\\n}\\n\\n// 错误\\nconst isExist = arr.find(item => item === 0)\\nif (isExist) { // isExist此时是0，隐式转换为布尔值后是false\\n    console.log('执行不到这里~')\\n}\\n\\n\\n// 当子项包含空字符串的时候也可能出错\\nconst arr = ['', 'asdf', 'qwer', '...']\\n\\n// 正确\\nconst isExist = arr.some(item => item === '')\\nif (isExist) {\\n    console.log('存在要找的子项，很舒服~')\\n}\\n\\n// 错误\\nconst isExist = arr.find(item => item === '')\\nif (isExist) { // isExist此时是''，隐式转换为布尔值后是false\\n    console.log('执行不到这里~')\\n}\\narray.find() 和 array.filter()\\n只需要知道 array.filter() 返回的是所有符合条件的子项组成的数组，会遍历所有数组；而 array.find() 只返回第一个符合条件的子项，是短路操作。不再举例~\\n合理使用 Set 数据结构\\n由于 es6 原生提供了 Set 数据结构，而 Set 可以保证子项不重复，且和数组转换十分方便，所以在一些可能会涉及重复添加的场景下可以直接使用 Set 代替 Array，避免了多个地方重复判断是否已经存在该子项。\\nconst set = new Set()\\nset.add(1)\\nset.add(1)\\nset.add(1)\\nset.size // 1\\nconst arr = [...set] // arr: [1]\\n强大的reduce\\narray.reduce 遍历并将当前次回调函数的返回值作为下一次回调函数执行的第一个参数。\\n利用 array.reduce 替代一些需要多次遍历的场景，可以提高代码运行效率。\\n假如有如下每个元素都由字母's'加数字组成的数组arr，现在找出其中最大的数字：（arr不为空）\\nconst arr = ['s0', 's4', 's1', 's2', 's8', 's3']\\n\\n// 方法1  进行了多次遍历，低效\\nconst newArr = arr.map(item => item.substring(1)).map(item => Number(item))\\nconst maxS = Math.max(...newArr)\\n\\n// 方法2  一次遍历\\nconst maxS = arr.reduce((prev, cur) => {\\n  const curIndex = Number(cur.replace('s', ''))\\n  return curIndex > prev ? curIndex : prev\\n}, 0)\\nconst arr = [1, 2, 3, 4, 5]\\n\\n // 方法1  遍历了两次，效率低\\nconst value = arr.filter(item => item % 2 === 0).map(item => ({ value: item }))\\n\\n// 方法1  一次遍历，效率高\\nconst value = arr.reduce((prev, curr) => {\\n    return curr % 2 === 0 ? [...prev, curr] : prev\\n}, [])\\n\\n也可用 reduce 做下面这样的处理来生成想要的 html 结构：\\n// 后端返回数据\\nconst data = {\\n  'if _ then s9': [\\n    '作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生',\\n    '作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生',\\n    '作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生'\\n    ],\\n  'if C then s4': [\\n    '当有条件时时,结构构件满足要求,要求属于安全性、适用性和耐久性',\\n    '当有条件时时,住宅结构满足要求,要求属于安全性、适用性和耐久性'\\n  ]\\n}\\n\\nconst ifthens = Object.entries(data).reduce((prev, cur) => {\\n  const values = cur[1].reduce((prev, cur) => `${prev}<p>${cur}</p>`, '')\\n  return `\\n    ${prev}\\n    <li>\\n      <p>${cur[0]}</p>\\n      ${values}\\n    </li>\\n  `\\n}, '')\\n\\nconst html = `\\n  <ul class=\\\"nlp-notify-body\\\">\\n    ${ifthens}\\n  </ul>\\n`\\n生成的 html 结构如下：\\n<ul class=\\\"nlp-notify-body\\\">            \\n  <li>\\n    <p>if _ then s9</p>\\n    <p>作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生</p>\\n    <p>作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生</p>\\n    <p>作用属于各种,结构属于住宅,结构能承受作用,作用属于在正常建造和正常使用过程中可能发生</p>\\n  </li>\\n  <li>\\n    <p>if C then s4</p>\\n    <p>当有条件时时,结构构件满足要求,要求属于安全性、适用性和耐久性</p>\\n    <p>当有条件时时,住宅结构满足要求,要求属于安全性、适用性和耐久性</p>\\n  </li>\\n</ul>\\n\")])])])])}),[],!1,null,null,null);r.default=a.exports}}]);","extractedComments":[]}